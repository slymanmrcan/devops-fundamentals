import{_ as a,o as i,c as r,ag as l}from"./chunks/framework.DhRkhqU-.js";const m=JSON.parse('{"title":"Sertifikasyon Hazırlık Soruları","description":"","frontmatter":{},"headers":[],"relativePath":"12-Certifications/01-Practice-Questions.md","filePath":"12-Certifications/01-Practice-Questions.md"}'),o={name:"12-Certifications/01-Practice-Questions.md"};function n(t,e,s,u,d,c){return i(),r("div",null,[...e[0]||(e[0]=[l('<h1 id="sertifikasyon-hazırlık-soruları" tabindex="-1">Sertifikasyon Hazırlık Soruları <a class="header-anchor" href="#sertifikasyon-hazırlık-soruları" aria-label="Permalink to &quot;Sertifikasyon Hazırlık Soruları&quot;">​</a></h1><p>Bu bölüm, popüler DevOps sertifikasyon sınavlarına (AWS, Kubernetes, Terraform) hazırlanmanıza yardımcı olacak örnek soruları ve açıklamalı cevapları içerir.</p><hr><h2 id="_1-aws-solutions-architect-developer" tabindex="-1">1. AWS (Solutions Architect / Developer) <a class="header-anchor" href="#_1-aws-solutions-architect-developer" aria-label="Permalink to &quot;1. AWS (Solutions Architect / Developer)&quot;">​</a></h2><h3 id="soru-1-s3-veri-guvenligi" tabindex="-1">Soru 1: S3 Veri Güvenliği <a class="header-anchor" href="#soru-1-s3-veri-guvenligi" aria-label="Permalink to &quot;Soru 1: S3 Veri Güvenliği&quot;">​</a></h3><p><strong>Senaryo:</strong> Şirketinizin S3 bucket&#39;ındaki kritik verilerin yanlışlıkla silinmesini veya üzerine yazılmasını engellemek istiyorsunuz. En etkili ve hızlı çözüm nedir?</p><ul><li>A) Bucket Policy ile herkesin erişimini kapatmak.</li><li>B) S3 Versioning&#39;i (Sürümleme) etkinleştirmek. ✅</li><li>C) MFA Delete (Çok Faktörlü Silme) özelliğini açmak.</li><li>D) Verileri her gece başka bir Region&#39;a kopyalamak.</li></ul><blockquote><p><strong>Cevap B:</strong> Versioning, bir dosyanın silinmesi veya değiştirilmesi durumunda eski kopyasını saklar. MFA Delete de iyidir ancak Versioning temel korumadır.</p></blockquote><h3 id="soru-2-ec2-maliyet-optimizasyonu" tabindex="-1">Soru 2: EC2 Maliyet Optimizasyonu <a class="header-anchor" href="#soru-2-ec2-maliyet-optimizasyonu" aria-label="Permalink to &quot;Soru 2: EC2 Maliyet Optimizasyonu&quot;">​</a></h3><p><strong>Senaryo:</strong> Sadece mesai saatlerinde (09:00-18:00) çalışan bir test ortamınız var. Maliyeti en aza indirmek için hangi fiyatlandırma modelini seçmelisiniz?</p><ul><li>A) On-Demand Instances (İsteğe Bağlı). ✅</li><li>B) Reserved Instances (Rezerve Edilmiş).</li><li>C) Spot Instances.</li><li>D) Dedicated Hosts.</li></ul><blockquote><p><strong>Cevap A:</strong> Günde sadece 9 saat çalışan ve kesintiye tahammülü olan (test) bir sistem için On-Demand mantıklıdır. Spot daha ucuzdur ama sunucu kapanabilir (testler yarım kalabilir). Reserved ise 7/24 kullanım içindir.</p></blockquote><h3 id="soru-3-vpc-guvenligi" tabindex="-1">Soru 3: VPC Güvenliği <a class="header-anchor" href="#soru-3-vpc-guvenligi" aria-label="Permalink to &quot;Soru 3: VPC Güvenliği&quot;">​</a></h3><p><strong>Senaryo:</strong> Private Subnet&#39;teki bir veritabanı sunucusunun, güncelleme indirmek için internete erişmesi gerekiyor. Ancak internetten kimse veritabanına erişememeli. Ne kullanmalısınız?</p><ul><li>A) Internet Gateway (IGW).</li><li>B) NAT Gateway. ✅</li><li>C) Egress-Only Internet Gateway.</li><li>D) VPC Peering.</li></ul><blockquote><p><strong>Cevap B:</strong> NAT Gateway, özel ağdaki cihazların dışarı çıkmasına izin verir ama dışarıdan içeriye bağlantı kabul etmez.</p></blockquote><hr><h2 id="_2-kubernetes-cka-ckad" tabindex="-1">2. Kubernetes (CKA / CKAD) <a class="header-anchor" href="#_2-kubernetes-cka-ckad" aria-label="Permalink to &quot;2. Kubernetes (CKA / CKAD)&quot;">​</a></h2><h3 id="soru-4-pod-sorun-giderme" tabindex="-1">Soru 4: Pod Sorun Giderme <a class="header-anchor" href="#soru-4-pod-sorun-giderme" aria-label="Permalink to &quot;Soru 4: Pod Sorun Giderme&quot;">​</a></h3><p><strong>Senaryo:</strong> Bir Pod <code>CrashLoopBackOff</code> hatası veriyor. Sorunun nedenini anlamak için hangi komutu kullanmalısınız?</p><ul><li>A) <code>kubectl get pods</code></li><li>B) <code>kubectl describe pod &lt;pod-adı&gt;</code></li><li>C) <code>kubectl logs &lt;pod-adı&gt; --previous</code> ✅</li><li>D) <code>kubectl delete pod &lt;pod-adı&gt;</code></li></ul><blockquote><p><strong>Cevap C:</strong> Pod sürekli çöküp yeniden başlıyorsa, <code>logs</code> komutu (özellikle <code>--previous</code> ile) uygulamanın neden öldüğünü (örn: kod hatası) gösterir. <code>describe</code> ise olayları (events) gösterir.</p></blockquote><h3 id="soru-5-service-tipleri" tabindex="-1">Soru 5: Service Tipleri <a class="header-anchor" href="#soru-5-service-tipleri" aria-label="Permalink to &quot;Soru 5: Service Tipleri&quot;">​</a></h3><p><strong>Senaryo:</strong> Uygulamanızı internete açmak istiyorsunuz ve AWS üzerinde çalışıyorsunuz. Hangi Service tipini kullanmak en kolayıdır?</p><ul><li>A) ClusterIP</li><li>B) NodePort</li><li>C) LoadBalancer ✅</li><li>D) ExternalName</li></ul><blockquote><p><strong>Cevap C:</strong> LoadBalancer tipi, bulut sağlayıcısının (AWS ALB/NLB) yük dengeleyicisini otomatik olarak oluşturur ve trafiği Pod&#39;lara yönlendirir.</p></blockquote><hr><h2 id="_3-terraform-associate" tabindex="-1">3. Terraform (Associate) <a class="header-anchor" href="#_3-terraform-associate" aria-label="Permalink to &quot;3. Terraform (Associate)&quot;">​</a></h2><h3 id="soru-6-state-yonetimi" tabindex="-1">Soru 6: State Yönetimi <a class="header-anchor" href="#soru-6-state-yonetimi" aria-label="Permalink to &quot;Soru 6: State Yönetimi&quot;">​</a></h3><p><strong>Senaryo:</strong> Ekip arkadaşınızla aynı Terraform projesinde çalışıyorsunuz. <code>terraform apply</code> yaparken birbirinizin değişikliklerini ezmemek için ne yapmalısınız?</p><ul><li>A) Herkes kendi bilgisayarında state tutmalı.</li><li>B) State dosyasını Git&#39;e atmalı.</li><li>C) Remote State (S3 + DynamoDB Locking) kullanmalı. ✅</li><li>D) Her seferinde yeni klasör açmalı.</li></ul><blockquote><p><strong>Cevap C:</strong> Remote State (uzak durum), state dosyasını merkezi bir yerde tutar. DynamoDB kilitlemesi (locking) ise aynı anda iki kişinin yazmasını engeller.</p></blockquote><h3 id="soru-7-plan-vs-apply" tabindex="-1">Soru 7: Plan vs Apply <a class="header-anchor" href="#soru-7-plan-vs-apply" aria-label="Permalink to &quot;Soru 7: Plan vs Apply&quot;">​</a></h3><p><strong>Senaryo:</strong> <code>terraform plan</code> komutu ne yapar?</p><ul><li>A) Altyapıyı oluşturur.</li><li>B) Altyapıyı siler.</li><li>C) Yapılacak değişikliklerin bir önizlemesini gösterir, hiçbir şeyi değiştirmez. ✅</li><li>D) Kodunuzdaki hataları düzeltir.</li></ul><blockquote><p><strong>Cevap C:</strong> Plan, &quot;Eğer apply dersen şunlar olacak&quot; diyen güvenli bir simülasyondur.</p></blockquote><hr><h2 id="_4-git-devops" tabindex="-1">4. Git &amp; DevOps <a class="header-anchor" href="#_4-git-devops" aria-label="Permalink to &quot;4. Git &amp; DevOps&quot;">​</a></h2><h3 id="soru-8-git-branching" tabindex="-1">Soru 8: Git Branching <a class="header-anchor" href="#soru-8-git-branching" aria-label="Permalink to &quot;Soru 8: Git Branching&quot;">​</a></h3><p><strong>Senaryo:</strong> <code>main</code> branch&#39;inde canlıdaki kod var. Yeni bir özellik geliştirirken <code>main</code>&#39;i bozmamak için ne yapmalısınız?</p><ul><li>A) Doğrudan <code>main</code>&#39;e commit atmalı.</li><li>B) Yeni bir <code>feature</code> branch&#39;i açıp orada çalışmalı. ✅</li><li>C) Kodu Google Drive&#39;a yedeklemeli.</li><li>D) Başka bir repo oluşturmalı.</li></ul><blockquote><p><strong>Cevap B:</strong> Feature branch, ana koddan izole bir çalışma alanı sağlar. İş bitince <code>main</code>&#39;e merge edilir (birleştirilir).</p></blockquote>',42)])])}const p=a(o,[["render",n]]);export{m as __pageData,p as default};
